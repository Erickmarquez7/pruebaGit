Ps parte 1 explicar que pedo
- Como es que guarda la informacion, a través de fotos y refrencias
Mas no las diferencias

- Explicar los 3 estados de archivo, así como las 3 areas

-- Comandos 
    git config --global user.email = ...
    git config --global user.name = ...
    git config --list

    git help --comando
    git init
    git add <archivo>
    git status
    git commit <archivo>

Ejercicios xd:
Crear archivo y modificarlo de tal manera que al ejecutar git status -s tengan las letras (No importa el orden)

??    - Archivo no rastreado
A     - Archivo recién rastreado
M     - Cuando modificas el archivo y lo añades al stage, preparado
 M    - Solo modificas el archivo, sin preparar, no has hecho add 
MM    - Cuando de ultimo minuto modificas el archivo pero no lo has añadido
        haciendo así que aparezca tanto en confirmado como no confirmado
 D    - Delete no preparado
D     - Delete preaparado  

git add (MM) -> (M)
pk ya lo subiste al stage
------------------------------------------------------------------------------------
| Ignorar archivos
Creando un archivo .gitignore y poniendo los que no queremos que tome en cuenta
*.[abc] ignora los que terminan en .a || .b || .c, o sea los [] lo hacen or

*.~ ignora los que terminen en ~ 
*.java los que terminan en java, es decir toda la cadena

? Caracter cualquiera

[0-9] Cualquier caracter entre ellos

a/**/z Cualquier directorio entre ellos, anidados a/z, a/b/c, a/b/f/z

#comentario en tal archivo xd
/comenzando así evita la recursividad
Así al final especifica un directoio/
!Niega la expresión

ejemplos:

#niega todos los javac
*.javac 

#excepto este, aun cuando se especificó anteriormente
!main.javac

#ignora solo el archivo ridmi de la raiz, mas no de la subcarpetas
/ridmi

#todos los archivos de la carpeta images
/images

#ignora doc/notes.txt, pero no doc/sub/notes.txt
doc/*.txt

#para eso es, ignora TODOS los archivos .txt 
doc/**/*.txt

-- Es recomendable hacer esto al iniciar un repoxd

Editado pero no preparado
| 
git diff 
Así a secas muestra las diferencias entre lo que estoy trabajando y lo que está
en el stage, cambios que aun NO están preparados

git diff --staged
Lo que he preparado y será incluido en la confirmacion

git commit -m "con mensaje"

| Eliminar archivos
Es necesario eliminarlos del staged
git rm 
Lo elimina del work directory así como del staged, es decir, lo prepara

git rm --staged || --cached <archivo>
Lo elimina solo del stage, se mantiene en el work directory

Admite expresiones regulares

Podemos renombrar archivos con 
git mv

Para el historial
git log

Podemos pasarle parametros para buscar lo que queremos
-p mustra el historial con sus diferencias
-2 los ultimos 2
-n los ultimos n
--stat estadisticas 
--pretty añade estilo
    =oneline lo imprime en una linea
    =short ps corto
    =format: para añadir formato
        "%h"   hash abreviado, total con mayuscula
        "%t"   hash del arbol abreviado
        "%p"   hashes del padre abreviado
        "%an"  nombre del autor
        "%ae"  email del autor
        "ar"   fecha
        "%s"   asunto

git log --pretty="format: %h - %an, : %s"

--graph muestra el grafo
--since=2.weeks
Fecha en especifico
--since="2020-10-10"
Desde el 2020 octubre 10
--until="2020-20-11"
hasta el siguiente dia xd
--author
por autor xd

Conclusion, ps son consultas en bases de datos

git commit --amend sobre escribe el commit anterior, por si se te olvidó algo xd
ps pa que no hagas dos commits

git restore --staged <archivo> saca archivos del staged
git restore <archivo> devuelve al estado anterior al archivo modificado

Así que Ojazo con este ultimo xd


-----------------------------REMOTOS--------------------------
Remoto es basicamente el servidor en linea, por lo general es origin
git remote pa ver los remotos 
-v para ver los link asociados

git remote add [nombre] [url] para añadir remoto
git remote add origin https://marquezErick/....

git fetch [nombre-del-remoto] trae todos los cambios que aun no tengo en dicho remoto
git fecth origin

*Cuando clonamos un repo git clone, el comando automaticamente añade el remoto origin
clone es como un git init; git remote add origin; git fetch, todo en uno xd

git fecth Solo trae la info, NO la mezcla

git pull trae y combina dichos cambios a la rama que configuré

git push [nombre-remoto] [nombre-rama] envio los cambios al servidor de mi rama master
git push origin master

git remote show [nombre-rama] muestra mas detallada 

git remote rename [anterior] [nueva] renombra el remoto


------------------------ALIAS-----------------------------
Recordemos la configuración de config

git config --global ......

Podemos definir alias de comandos

git config --global alias.[newComm] [commando]

ejemplos
git config --global alias.co commit
git config --global alias.st status
